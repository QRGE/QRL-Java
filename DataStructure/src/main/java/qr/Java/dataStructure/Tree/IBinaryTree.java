package qr.Java.dataStructure.Tree;

/**
 * Binary ITree 特点:
 * <li>每个节点的度最大为2</li>
 * <li>左子树和右子树是有具体的,即使某个节点只有一颗子树, 也要区分左右子树</li>
 * <li>非空二叉树的第i层, 最多有2^(i-1)个节点</li>
 * <li>高度为h的二叉树最多有2^h-1个节点</li><br/>
 *
 * 对于任何一颗非空二叉树, 假设叶子节点个数为n0, 度为1的节点个数为n1, 度为2的节点个数为n2, 则有:
 * <li>n0 = n2 + 1</li>
 * <li>推到过程: 二叉树的边数T = n1 + 2*n2 = n-1(只有根节点上面没有边) = n0 + n1 + n2 - 1</li><br/>
 *
 * 真二叉树: 所有节点的度都为0或2<br/>
 * 满二叉树: 所有节点的度都为0或2, 且所有的叶子节点都在最后一层<br/>
 *
 * 完全二叉树:
 *      叶子节点只会出现在最后2层, 且最后1层的叶子节点都靠左对齐
 *      按照满二叉树的顺序排列
 * 完全二叉树的性质:
 *      度为1的节点只有左子树(度为1的节点要么为1个, 要么为0个)
 *      h = floor(log2n) + 1
 *      一颗有n个节点的完全二叉树(n>0), 从上到下, 从左到右从1开始编号, 对于任意第i个节点:
 *          如果i = 1, 它是根节点
 *          如果i > 1, 其父节点编号为floor(i/2)
 *          如果2i <= n, 它的左子节点编号为2i
 *              如果2i + 1 <= n, 它的右子节点编号为2i + 1
 *          如果2i>n, 它无左子节点
 *              如果2i + 1 > n, 它无右子节点
 * @Author: QR
 * @Date: 2021/7/4-16:01
 */
public interface IBinaryTree {
}
