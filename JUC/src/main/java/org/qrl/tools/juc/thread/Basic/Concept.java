package org.qrl.tools.juc.thread.Basic;

/**
 * 多线程可以让你最大限度地利用CPU
 *
 * 创建一个线程类的方式:
 *      继承Thread类
 *      实现Runnable接口, 并作为Thread的构造方法的参数传入
 *
 * 由于Java时单继承, 利用实现Runnable接口的方法创造线程类可以实现更多功能
 *
 * 各个线程的启动顺序 和 代码顺序 可能并没有关系
 *
 * 线程的状态:
 * 线程在一定条件下，状态会发生变化。线程一共有以下几种状态：
 *      New: 新创建了一个线程对象
 *      Runnable: 线程对象创建后,其他线程调用了该对象的start()方法。
 *                        该状态的线程位于"可运行线程池"中，变得可运行，只等待获取CPU的使用权，
 *                        即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。
 *      Running: 就绪状态的线程获取了CPU，执行程序代码。
 *      Blocked: 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。
 *
 * 阻塞的情况分三种：
 *      等待阻塞: 运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，
 *              必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒
 *      同步阻塞: 运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中
 *      其他阻塞: 运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态
 *              当sleep()状态超时、join()等待线程终止或者超时，或者I/O处理完毕时，线程重新转入Runnable状态。
 *      Dead: 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
 */
public class Concept {
}
